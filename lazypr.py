"""LazyPR - AI-powered PR creation from git diffs."""

import os
import re
import shutil
import subprocess
from pathlib import Path
from typing import Optional

import pathspec
import typer
from pydantic import BaseModel, Field
from pydantic_ai import Agent
from pydantic_ai.models import ModelSettings
from rich.console import Console

console = Console()

app = typer.Typer(help="AI-powered PR creation from git diffs")


# Custom exceptions
class ValidationError(Exception):
    """Raised when validation fails."""
    pass


class DiffError(Exception):
    """Raised when diff operations fail."""
    pass


class AIError(Exception):
    """Raised when AI generation fails."""
    pass


# Pydantic models
class PRContent(BaseModel):
    """PR title and description generated by AI."""
    title: str = Field(description="Concise PR title (max 72 chars)")
    description: str = Field(description="PR description summarizing the changes")


# Configuration functions
def get_max_diff_lines() -> int:
    """Get max diff lines from environment variable."""
    value = os.environ.get("LAZYPR_MAX_DIFF_LINES", "1000")
    try:
        return int(value)
    except ValueError:
        return 1000


def get_model_name() -> Optional[str]:
    """Get ZAI model name from environment variable."""
    return os.environ.get("LAZYPR_MODEL")


def get_api_key() -> Optional[str]:
    """Get API key from environment variable."""
    return os.environ.get("LAZYPR_API_KEY")


# Validation functions
def is_git_repo() -> bool:
    """Check if we're in a git repository."""
    return os.path.isdir(".git")


def _git_command_succeeds(cmd: list[str]) -> bool:
    """Check if a git command succeeds."""
    try:
        subprocess.run(cmd, capture_output=True, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def has_gh_cli() -> bool:
    """Check if gh CLI is installed."""
    return shutil.which("gh") is not None


def gh_is_authenticated() -> bool:
    """Check if gh CLI is authenticated."""
    try:
        subprocess.run(
            ["gh", "auth", "status"],
            capture_output=True,
            check=True
        )
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def has_remote(remote: str = "origin") -> bool:
    """Check if a remote is configured."""
    try:
        result = subprocess.run(
            ["git", "remote"],
            capture_output=True,
            text=True,
            check=True
        )
        remotes = result.stdout.strip().split("\n")
        return remote in remotes
    except subprocess.CalledProcessError:
        return False


def get_current_branch() -> str:
    """Get the current git branch name."""
    try:
        result = subprocess.run(
            ["git", "branch", "--show-current"],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        raise ValidationError("Failed to get current branch") from e


def has_commits_ahead(base: str) -> bool:
    """Check if current branch has commits ahead of base."""
    try:
        result = subprocess.run(
            ["git", "rev-list", f"{base}..HEAD"],
            capture_output=True,
            text=True,
            check=True
        )
        return len(result.stdout.strip()) > 0
    except subprocess.CalledProcessError:
        return False


# Diff handling functions
def get_diff(base: str) -> str:
    """Get diff from base branch to current HEAD."""
    try:
        result = subprocess.run(
            ["git", "diff", f"{base}...HEAD"],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        raise DiffError(f"Failed to get diff from base branch '{base}'") from e


def _is_diff_content_line(line: str) -> bool:
    """Check if a line is part of a file's diff content (not a separator)."""
    return (
        line.startswith("index ") or
        line.startswith("--- ") or
        line.startswith("+++ ") or
        line.startswith("@@") or
        line.startswith("+") or
        line.startswith("-") or
        line.startswith(" ") or
        line == "\\ No newline at end of file"
    )


def _parse_hunk_line_count(line: str) -> Optional[int]:
    """Extract the number of added lines from a hunk header like '@@ -1,1000 +1,1000 @@'."""
    # Match patterns like @@ -1,1000 +1,1000 @@ or @@ -1 +1 @@
    # The number after the comma in the + section is the line count
    match = re.match(r'@@ -\d+(?:,\d+)? \+\d+,?(\d+)? @@', line)
    if match:
        count_str = match.group(1)
        if count_str:
            return int(count_str)
    return None


def parse_diff_lines(diff: str) -> dict[str, int]:
    """Parse diff and return a dict mapping file paths to actual line counts."""
    file_lines: dict[str, int] = {}
    current_file: Optional[str] = None
    current_count = 0

    # Normalize line endings and split
    lines = diff.replace("\r\n", "\n").split("\n")
    # Remove trailing empty line if present
    if lines and lines[-1] == "":
        lines = lines[:-1]

    for line in lines:
        # Check for file header
        if line.startswith("diff --git "):
            # Save previous file count
            if current_file is not None:
                file_lines[current_file] = current_count
            # Extract new file path
            match = re.match(r'diff --git a/(.*) b/(.*)', line)
            if match:
                current_file = match.group(2)
                current_count = 1  # Count the diff --git line
            else:
                current_file = None
                current_count = 0
        elif current_file is not None:
            # Check for binary files
            if line == "Binary files differ":
                # Remove binary file from tracking
                current_file = None
                current_count = 0
            elif _is_diff_content_line(line):
                current_count += 1
            # Ignore empty lines and separators between files

    # Save last file
    if current_file is not None:
        file_lines[current_file] = current_count

    return file_lines


def _get_effective_line_count(diff: str) -> dict[str, int]:
    """Get effective line count for filtering purposes.

    Uses hunk header line count when available (e.g., @@ -1,1000 +1,1000 @@ returns 1000),
    otherwise falls back to actual line count.
    """
    actual_counts = parse_diff_lines(diff)
    effective_counts: dict[str, int] = {}

    # Normalize line endings and split
    lines = diff.replace("\r\n", "\n").split("\n")
    if lines and lines[-1] == "":
        lines = lines[:-1]

    current_file: Optional[str] = None

    for line in lines:
        if line.startswith("diff --git "):
            match = re.match(r'diff --git a/(.*) b/(.*)', line)
            if match:
                current_file = match.group(2)
                effective_counts[current_file] = actual_counts.get(current_file, 0)
        elif current_file is not None and line.startswith("@@"):
            hunk_count = _parse_hunk_line_count(line)
            if hunk_count is not None and hunk_count > effective_counts.get(current_file, 0):
                effective_counts[current_file] = hunk_count

    return effective_counts


def filter_large_files(diff: str, max_lines: int) -> str:
    """Remove files from diff that exceed max_lines."""
    if not diff.strip():
        return ""

    file_lines = _get_effective_line_count(diff)
    files_to_remove = {f for f, count in file_lines.items() if count > max_lines}

    if not files_to_remove:
        return diff

    # Normalize line endings and split
    lines = diff.replace("\r\n", "\n").split("\n")
    # Remove trailing empty line if present for processing
    has_trailing_newline = lines and lines[-1] == ""
    if has_trailing_newline:
        lines = lines[:-1]

    # Collect lines for each file separately
    files_in_diff: dict[str, list[str]] = {}
    current_file: Optional[str] = None

    for line in lines:
        if line.startswith("diff --git "):
            # Extract file path
            match = re.match(r'diff --git a/(.*) b/(.*)', line)
            if match:
                current_file = match.group(2)
                files_in_diff[current_file] = [line]
            else:
                current_file = None
        elif current_file is not None:
            files_in_diff[current_file].append(line)

    # Rebuild diff without large files
    filtered_lines: list[str] = []
    for filename, file_lines_list in files_in_diff.items():
        if filename not in files_to_remove:
            filtered_lines.extend(file_lines_list)

    if not filtered_lines:
        return ""

    return "\n".join(filtered_lines) + "\n"


# Ignore pattern functions
def load_ignore_patterns() -> list[str]:
    """Load ignore patterns from .lazyprignore file."""
    ignore_file = Path(".lazyprignore")
    if not ignore_file.exists():
        return []

    patterns: list[str] = []
    with open(ignore_file, "r") as f:
        for line in f:
            line = line.rstrip("\n\r")
            # Skip comments and empty lines
            if line and not line.startswith("#"):
                patterns.append(line)

    return patterns


def matches_pattern(pattern: str, filepath: str) -> bool:
    """Check if filepath matches a gitignore-style pattern."""
    # Handle negation patterns
    if pattern.startswith("!"):
        pattern = pattern[1:]
        # For negation, we check if it matches - caller decides meaning
        spec = pathspec.PathSpec.from_lines("gitwildmatch", [pattern])
        return spec.match_file(filepath)

    spec = pathspec.PathSpec.from_lines("gitwildmatch", [pattern])
    return spec.match_file(filepath)


def apply_ignore_patterns(files: list[str], patterns: list[str]) -> list[str]:
    """Filter out files matching ignore patterns."""
    if not patterns:
        return files

    # Separate regular patterns from negation patterns
    regular_patterns: list[str] = []
    negation_patterns: list[str] = []

    for pattern in patterns:
        if pattern.startswith("!"):
            negation_patterns.append(pattern[1:])
        else:
            regular_patterns.append(pattern)

    result: list[str] = []

    for filepath in files:
        # Check if file matches any regular pattern
        ignored = False
        for pattern in regular_patterns:
            if matches_pattern(pattern, filepath):
                ignored = True
                break

        # Check negation patterns (re-include if matches)
        if ignored:
            for pattern in negation_patterns:
                if matches_pattern(pattern, filepath):
                    ignored = False
                    break

        if not ignored:
            result.append(filepath)

    return result


# AI functions
def create_pr_agent() -> Agent:
    """Create a PydanticAI agent for PR generation."""
    model_name = get_model_name()
    # api_key = get_api_key()

    if not model_name:
        raise AIError("LAZYPR_MODEL environment variable not set")

    # Create agent with structured output
    agent = Agent(
        model=model_name,
        output_type=PRContent,
        system_prompt="""You are a helpful assistant that generates clear and professional pull request titles and descriptions from git diffs.

Always output valid JSON with fields: title (max 72 chars), description
""",
        model_settings=ModelSettings(
            temperature=0.3,
        ),
    )

    return agent


async def generate_pr_content(diff: str) -> PRContent:
    """Generate PR title and description from diff using AI."""
    agent = create_pr_agent()

    prompt = f"""You are an assistant specialized in documenting Pull Requests clearly and professionally.

Analyze the provided code diff and generate a PR description following this structure:

## Description Structure

### 1. Summary (1-2 sentences)
Explain WHAT was done in terms of functionality/impact, not technical implementation.

### 2. Context and Motivation (1 short paragraph)
- Why was this change necessary?
- What problem does it solve or what functionality does it add?
- Link to issue/ticket if available

### 3. Main Changes (bullet points)
List the most significant changes:
- Use concise bullets (1 line each)
- Focus on CHANGES, not "added file X"
- Group related changes together
- Maximum 5-7 bullets (if more, group them)

### 4. Technical Details (if relevant)
Only if there are important technical decisions:
- Architecture choices
- Trade-offs considered
- Breaking changes

### 5. How to Test (if applicable)
- Steps to verify functionality
- Important edge cases

## Tone Guidelines
- Use clear and direct language
- Avoid unnecessary jargon
- Be concise but complete
- Write thinking of the reviewer (don't assume they know all the context)

## What NOT to do
- Don't list every modified file (the diff already shows that)
- Don't use generic phrases like "code improvements"
- Don't copy commit messages directly
- Don't be overly technical in the summary

---

Now generate the PR title and description for the following diff:

```diff
{diff}
```

Provide output as JSON with fields: title, description"""

    result = await agent.run(prompt)
    return result.output


# PR creation function
def create_pr(title: str, description: str, base: str) -> None:
    """Create a PR using gh CLI."""
    try:
        subprocess.run(
            [
                "gh", "pr", "create",
                "-w",
                "--base", base,
                "--title", title,
                "--body", description,
            ],
            check=True,
        )
    except subprocess.CalledProcessError as e:
        raise ValidationError(f"Failed to create PR: {e}") from e


# CLI command
@app.command(name="create")
def create_cmd(
    base: str = typer.Option(..., "--base", help="Base branch to compare against"),
) -> None:
    """Create a PR with AI-generated title and description."""
    import asyncio

    asyncio.run(create(base))


async def create(base: str) -> None:
    """Async implementation of create command."""
    # Validation checks
    if not is_git_repo():
        raise ValidationError("Not in a git repository")

    if not has_gh_cli():
        raise ValidationError("gh CLI not installed")

    if not gh_is_authenticated():
        raise ValidationError("gh CLI not authenticated. Run 'gh auth login'")

    if not has_remote("origin"):
        raise ValidationError("No 'origin' remote found")

    current_branch = get_current_branch()
    typer.echo(f"Current branch: {current_branch}")

    if not has_commits_ahead(base):
        raise ValidationError(f"No commits ahead of '{base}'")

    # Get and filter diff
    typer.echo(f"Getting diff from {base}...")
    diff = get_diff(base)

    if not diff.strip():
        raise DiffError("No changes to include in PR")

    # Filter large files
    max_lines = get_max_diff_lines()
    filtered_diff = filter_large_files(diff, max_lines)

    # Load and apply ignore patterns
    patterns = load_ignore_patterns()
    file_lines = parse_diff_lines(filtered_diff)
    filtered_files = apply_ignore_patterns(list(file_lines.keys()), patterns)

    # Rebuild diff with only allowed files
    if set(file_lines.keys()) != set(filtered_files):
        filtered_diff = _rebuild_diff_with_files(filtered_diff, filtered_files)

    if not filtered_diff.strip():
        raise DiffError("No changes left after filtering")

    with console.status("[bold green]Generating PR content with AI...", spinner="dots"):
        pr_content = await generate_pr_content(filtered_diff)

    typer.echo(f"\nTitle: {pr_content.title}")
    typer.echo(f"Description:\n{pr_content.description}\n")

    # Create PR
    typer.echo("Creating PR and opening browser...")
    create_pr(pr_content.title, pr_content.description, base)


def _rebuild_diff_with_files(diff: str, allowed_files: list[str]) -> str:
    """Rebuild diff including only allowed files."""
    allowed_set = set(allowed_files)
    filtered_lines: list[str] = []
    current_file: Optional[str] = None
    include_current = False

    for line in diff.split("\n"):
        if line.startswith("diff --git "):
            match = re.match(r'diff --git a/(.*) b/(.*)', line)
            if match:
                current_file = match.group(2)
                include_current = current_file in allowed_set
            else:
                include_current = False

            if include_current:
                filtered_lines.append(line)
        elif include_current:
            filtered_lines.append(line)

    return "\n".join(filtered_lines).rstrip() + "\n" if filtered_lines else ""


def main() -> None:
    """Entry point for the CLI."""
    app()


if __name__ == "__main__":
    main()
